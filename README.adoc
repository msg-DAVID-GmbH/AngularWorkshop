= Angular Workshop
:toc:
:toclevels: 1
:sectnums:
:imagesdir: images

These are notes and code snippets from the Udemy Workshop https://www.udemy.com/the-complete-guide-to-angular-2[The complete guide to Angular]. The "Course Project" is published https://github.com/msg-DAVID-gmbh/AngularCourseProject[here]. Although this repository here uses code snippets from the Udemy Workshop, the original course is very much recommended.

*This workshop is still in development.*

== Introduction
* Angular = framework for reactive single-page-applications
** single-page = one HTML-file that gets changed by JS
** reactive = not necessarily a server-call (and if, can be done in the background)
* version madness
** "Angular.js" = Angular 1 = first version of framework
** "Angular 2" = first major rewrite, also known as simply "Angular"
** "Angular 3" skipped for some reason
** "Angular 4" and "Angular 5" = latest versions
** however, only two major and potentially incompatible versions: Angular.js and "the rest" a.k.a. "Angular" because only Angular 2 had major changes

== Setup Option 1: Just Angular
* this option: only little Angular project for learning plain angular
* following steps are for Windows machines; Linux can slightly diver

=== Install NodeJS
* https://nodejs.org/en/
* ... because Angular CLI needs it ...
* manages packages and loads a local development server

=== Install Angular CLI
* builds new projects that can than be used
* less setup, less writing boiler plate, more coding business logic
* in Windows console:

    npm install -g @angular/cli

* npm = Node package manager, came with NodeJS
* package.json in NPM comparable to pom.xml in Maven
* -g = global install
* @angular/cli = package

=== Create new Angular Project
* create new folder and navigate to it in console
* creating new project (in Windows console):

    ng new my-first-app

* "ng" stands for Angular
* my-first-app is the name of the app
* overview of what will be created:
** folder e2e contains end-to-end testing
** folder src/app should be the only location changes should be applied to
** src/index.html = HTML file that is changed by the Java Script of the framework. The dynamic content is inserted here:

  <body>
    <app-root></app-root>
  </body>

** folder node_modules is https://stackoverflow.com/questions/34526844/what-is-node-modules-directory-in-angularjs[just for build tools] and contains for example downloaded content like Bootstrap. Hence this is excluded in the .gitignore. These files are not necessary for deployment on server, just for development. For deployment, the content is bundled into one single file by the CLI.
** README.md contains the most important commands
** other single files = configuration; no need to touch ... maybe later

=== Run project
* navigate in created folder and run (in Windows console)

    ng serve

* will build all source code and run a dev server (see output for address)
* should be kept running all the time because changes in files are automatically saved, compiled and the app refreshed in the browser (without the need to hit F5!)

== Setup Option 2: JHipster = Angular with Spring Boot Backend and Deployment in Pivotal Cloud Foundry
* this option: complete and deployable application with Angular UI
* http://www.jhipster.tech[JHipster] = Spring Boot + Angular Generator

=== Install Yarn
* https://yarnpkg.com/lang/en/docs/install/#windows[Yarn] = Dependency Manager
* "yarn global add generator-jhipster" in Terminal will install Yarn

=== Create Project Folder

    mkdir testfolder && cd testfolder

=== Generate Project
* in Terminal:

    jhipster

=== Running Project locally
* running "ng serve" (like in Setup Option 1) in this folder doesn't work :(
* instead:
** "mvnw" to start Maven build and run application OR
** "yarn start" to start webpack development server for monitoring and generating beans and so on. Also notices changes in files and deploys them automatically OR
** via IDE: Maven Projects -> Plugins -> spring-boot -> spring-boot:run or simply execute run config (gets created automatically). This is also what will be done after deployment, so this is most likely the best option.
*** *Attention*: The application tends to switch to the prod-profile after deployment! To prevent this, add the VM Option "-Dspring.profiles.active=dev" in the run config.

=== Deployment to Pivotal Cloud Foundry
* for example in free version of https://run.pivotal.io[Pivotal Web Services]
* in terminal; explicit command to deploy to Cloud Foundry (see http://www.jhipster.tech/cloudfoundry/[help])

    jhipster cloudfoundry

* this will execute "cf push", create a route to the app and bind services like the database
* *Attention*:
** When running the first time, this will ask to overwrite the pom.xml because during build, additional dependencies are inserted. Overwrite the file.
** However, the new pom.xml doesn't get loaded with the first deployment. Hence, it will fail.
** "Solution": Deploy a second time.
** After this first run, every deployment will work fine.

=== Generating Entities with JDL-Studio
* http://www.jhipster.tech/jdl/[JDL = JHipster Domain Language]
* https://start.jhipster.tech/jdl-studio/[JDL Studio] = Online Generator for JDL-files that can be imported into JHipster and entities are created

== Package Management
=== NPM
* https://www.npmjs.com
* Node Package Manager
* = package manager for JavaScript
* (a lot of languages have package managers: PHP has Composer, Python has PyPi, Java has Gradle and Maven, ...)
* installing, sharing, distributing code
* *package.json* contains external dependencies, however just the first layer of dependencies. The underlying layers will be resolved automatically.
* *package-lock.json* is automatically created and contains the exact dependency tree and locks this tree to be used when resolving dependencies

=== Yarn
* = superset of NPM
* = "Yet Another Resource Negotiator"
* package manager that uses NPM registry as backend
* yarn.lock file stores exact versions of dependencies
* yarn updates yarn.lock automatically when dependencies are installed or updated (NPM needs the shrinkwrap command)
* very fast compared to NPM because NPM installs sequentially, Yarn in parallel
* installation for example:

    yarn add --dev webpack

* _--dev_ means that dependencies are installed in devDependencies array in package.json (for development) whereas omitting _--dev_ causes them to be installed in the dependencies-array (for production)
* used to run commands like this to run all scripts in the "build" section of the package.json file:

    yarn run build

==== Error: command xyz not found when running "yarn start"
* ran into this problem with "rimraf":

    C:\repositories\xyz>yarn run build
    yarn run v1.3.2
    $ yarn run webpack:prod
    $ yarn run cleanup && yarn run webpack:prod:main && yarn run clean-www
    $ rimraf build/{aot,www}
    Der Befehl "rimraf" ist entweder falsch geschrieben oder
    konnte nicht gefunden werden.


* solution: look at package.json: some dependencies have warnings that they are not installed. Alt+Enter and run "yarn install"

=== Babel
* JavaScript has different versions
* Babel converts new JavaScript code into older versions
* enables development with newest JS version without worrying about browser support

=== Webpack
* usage of for example SASS, PostCSS, minimizing CSS and minimizing JavaScript code with file webpack.config.js plus CLI command:

    webpack

* Webpack = modular build tool
* *loaders* transform source code, for example style-loader adds CSS to DOM
* *plugins* like UglifyJS minimizes output of webpack

== Tooling
* IntelliJ IDEA supports Angular right from the start:

image::angularSupportInWebStorm.png[]

* Reference search also working:

image::referenceSearchInIDEA.png[]

* also, https://www.jetbrains.com/webstorm/[WebStorm] is a lightweight IntelliJ IDEA and is suited for web development right away. However, IntelliJ IDEA https://stackoverflow.com/questions/13827214/can-intellij-idea-encapsulate-all-of-the-functionality-of-webstorm-and-phpstorm/13829907#13829907[can be upgraded via plugins to offer nearly the same functionality.]

=== Emmet
* https://emmet.io
* = Plugin for working with HTML and CSS
* already activated in IntelliJ IDEA
* workflow: write abbreviation, press Tab
* documentation for settings for https://www.jetbrains.com/help/idea/emmet-html.html[HTML-support] and https://www.jetbrains.com/help/idea/emmet-css.html[CSS-support]
* in settings "enable abbreviation preview":

image::emmetAbbreviationPreview.png[]

== TypeScript
* Angular uses TypeScript: files ending with "ts"
* superset of Java Script, which is a new statically, strongly-typed programming language on top of Java Script
* doesn't run in the browser, has to be compiled - that's what the CLI is for!
* type can either be stated explicitly:

    serverId:number = 10;

* type can also be omitted and chosen automatically:

    serverId = 10;

* with Ctrl + B, variables reveal their types:

image::typeCheckingWithCtrlB.png[]

=== Automatic Creation of Properties
* instead of writing this:

[source]
----
export class Ingredient {
    public name: string;
    public amount: number;

    constructor(name: string, amount: number) {
      this.name = name;
      this.amount = amount;
    }
  }
----

* ... this can be written with the same result:
[source]
----
export class Ingredient {

  constructor(public name: string, public amount: number) {
  }
}
----
* properties will be automatically created and assigned with the parameters of the constructor

=== Variable Declaration: var, let, const
* three options for declaring variable: var, let, const

==== var
* spoiler alert: least preferable from the three options
* traditional the way to declare a variable in JavaScript
* available in TypeScript because TypeScript = superset of JavaScript
* some odd "features" like "var-scoping": declarations of var are accessible anywhere, even globally. Details see https://www.typescriptlang.org/docs/handbook/variable-declarations.html[here]

==== let
* introduced because of the problems with var
* block-scoped = not visible outside of the block let was defined in
* behavior = expected behavior when coming from Java

==== const
* = augmentation of let; prevents re-assignment
* principle of least privilege: const should be used whenever re-assignment of variable is not intended

== Debugging
=== Developer Tools
* main problem: TypeScript getting translated into JavaScript
* solution: open developer tools in browser (in this example Vivaldi) (F12) -> "Sources"
* TypeScript sources available in the left window under webpack
* adding breakpoints like in IDE

=== Augury
* = Chrome extension specifically for debugging Angular applications
* https://augury.angular.io
* new tab in developer tools

== Bootstrap
* https://getbootstrap.com[Bootstrap] = toolkit for HTML, CSS and JS that provides a lot of ready-to-user CSS and components
* https://getbootstrap.com/docs/3.3/css/[CSS-styles] for tables, buttons, images and more
* https://getbootstrap.com/docs/3.3/components/[Components] like button groups, navigation bars and progress bars
* https://getbootstrap.com/docs/3.3/getting-started/#examples[basic examples as a starting point]

=== Usage in this course
* in the course, Bootstrap 3 is used. Hence use

[source]
----
    npm install --save bootstrap@3
----

instead of

[source]
----
    npm install --save bootstrap
----

* run this in IntelliJ IDEA via build-in Terminal will download Bootstrap
* after downloading, it has to be imported:
* open .angular-cli.json
* add something to the array of styles:

[source,json]
----
    "styles": [
            "styles.css"
          ],
----
* add newly downloaded Bootstrap-style from directory node_modules:
----
    "styles": [
            "../node_modules/bootstrap/dist/css/bootstrap.min.css",
            "styles.css"
          ],
----

== Writing Components
* components = key feature of Angular
* reusable
* separation of concerns because every component has its own controller and therefore business logic
* what is a component and what not is often the question at hand
* after creating project with CLI, following files in src/app:
** *app.component.css*
*** CSS file for this specific component
** *app.component.html*
*** template of this component
*** what is written in this file is being copied to wherever the component is being used
** *app.component.spec.ts*
*** tests
** *app.component.ts*
*** definition of the component
*** defines the name (="selector") of the component ("app-root") with which it can be used in other HTML-files
** *app.module.ts*
*** declarations and imports for the whole application
* naming convention in Angular: [name of component].component.[file type], for example "server.component.ts" is the type script file for the server component
* another aspect in Angular: "*Decorator*" = feature to enhance components with functionality, for example "@Component". Decorator needs information to know what to do with the annotated class, so a JSON object is provided:

  @Component({
    selector: 'app-root',
    templateUrl: './app.component.html',
    styleUrls: ['./app.component.css']
  })

=== Creating minimal Component
. create new directory in src/app, for example "server"
. create server.component.ts with a (unique!) selector and a reference to a template
. create template server.component.html
. register new component in app.module.ts in the declarations-array (there are other ways to make the new component known to the app, but that's the right way)
. use new component in app.component.html - NOT in the index.html because of best practice

=== Creating a Component via CLI
* open a *new* terminal window beside the one running _ng serve_
* the following will create a new component named "servers"

    ng generate component servers

* will create a new folder in _src/app_ and add an entry in app.module.ts, registering the new component
* pro-tip: There's a shortcut for this:

    ng g c servers

* for better structure, components should be encapsulated in a folder structure which can be defined by applying a path:

    ng g c management/technical/servers

== Databinding
* = Communication between TypeScript-Code (which is business logic) and the HTML-Template
* Output Data from TypeScript to HTML-Template:
** String Interpolation:

      {{data}}

** Property Binding:

     [property]="data"

* React to to events
** Event Binding:

    (event)="expression"

*** for example:

     <input type="text" class="form-control" (input)="onUpdateServerName($event)">

*** "$event" is the object automatically created with every event
* combination of both: Two-way-Binding:

     [(ngModel)]="data"

* Example: inserting images can be done two ways:
** 1. String Interpolation:

    <img
        src="{{recipe.imagePath}}"
        alt="{{recipe.name}}"
        class="img-responsive" style="max-height: 50px;">

** 2. Property Binding:

    <img
        [src]="recipe.imagePath"
        alt="{{recipe.name}}"
        class="img-responsive" style="max-height: 50px;">


== Directives
* = instructions in the DOM
* "Angular, please add something to the DOM"
* => components are directives, but directives with a template (there are also directives without a template)
* directives are inserted via attribute:

    <p colorThisText>Receives a green background</p>

    @Directive({
      selector: 'colorThisText'
    })
    export class ColorTextDirective {
      ...
    }

=== Structural Directives
* important build-in directive:

    <p *ngIf="serverCreated">Server was created, server name is {{serverName}}</p>

* star before "ngIf" indicates ngIf being a structural directive = changes the DOM
* another example: ngFor loops through an array (example displays list of app-server-components that each print out status of a single server):

    <app-server *ngFor="let server of servers"></app-server>

* another example for *ngIf with its else-part: only show a div if an item has been selected. If it hasn't been selected, show an infotext instead. This uses the local reference that is mentioned later in this tutorial.

  <div class="col-md-3">
    <app-detail
      *ngIf="selectedItem; else infotext"
      [selectedItem]="selectedItem"></app-detail>
  </div>
  <ng-template #infotext>
    <p>Select an item!</p>
  </ng-template>

* attention: no more than one structural directive allowed on the same element

=== Attribute Directives
* attribute-directives change elements they are placed on. Example for calling a method to get the color for a text:

    <p [ngStyle]="{color: getColor()}">Server with ID .. </p>

* example for marking all odd lines have a yellow background and all even ones a transparent background:

    <li
      [ngStyle]="{backgroundColor: odd % 2 !== 0 ? 'yellow' : 'transparent'}"
    ></li>

* another attribute-directive to apply CSS-classes:

    <p [ngClass]="{
      online: serverStatus === 'online',
      offline: serverStatus === 'offline'
      }">
      Server with ID ...</p>

=== Building own attribute Directive
* to write own directives, either create new folder "better-highlight" with file "better-highlight.directive.ts" ...
* ... or create everything needed for the directive "betterHighlight" with:

    ng g d better-highlight

* in better-highlight.directive.ts:
[source]
----
@Directive({
  selector: '[appBetterHighlight]'
})
export class BetterHighlightDirective implements OnInit {
  constructor(private elRef: ElementRef, private renderer: Renderer2) {}

  ngOnInit() {
    this.renderer.setStyle(this.elRef.nativeElement, 'background-color', 'green');
  }
}
----

* brackets in selector-name tell Angular that this is an attribute-directive
* the parameters in the constructor are injected by Angular and even created if not existing
* constructor parameter _elementRef_ = element the directive has been placed on
* _Renderer2_ is a better way of rendering elements - more methods see https://angular.io/api/core/Renderer2[here]
* keyword _private_ in constructor triggers creation of property
* directive doesn't have a view - hence only lifecycle hook _onInit_ and _onDestroy_ available
* new directives have to be added to app.module.ts in _declarations_
* usage in HTML:

    <p appBetterHighlight>My green text</p>

==== React on events with @HostListener

[source]
----
@Directive({
  selector: '[appBetterHighlight]'
})
export class BetterHighlightDirective implements OnInit {

  constructor(private elRef: ElementRef, private renderer: Renderer2) {}

  ngOnInit() {
  }

  @HostListener('mouseenter') mouseOver(eventData: Event) {
    this.renderer.setStyle(this.elRef.nativeElement, 'background-color', 'green');
  }

  @HostListener('mouseleave') mouseOver(eventData: Event) {
    this.renderer.setStyle(this.elRef.nativeElement, 'background-color', 'transparent');
  }
}
----

* decorator _HostListener_ is provided with the name of an event (in this case _mouseenter_) on which the specified method shall be executed

==== Bind properties with @HostBinding
[source]
----
@Directive({
  selector: '[appBetterHighlight]'
})
export class BetterHighlightDirective implements OnInit {

  constructor(private elRef: ElementRef, private renderer: Renderer2) {}

  ngOnInit() {
  }

  @HostBinding('style.backgroundColor') backgroundColor: string = 'transparent';

  @HostListener('mouseenter') mouseOver(eventData: Event) {
    this.backgroundColor = 'green';
  }

  @HostListener('mouseleave') mouseOver(eventData: Event) {
    this.backgroundColor = 'transparent';
  }
}
----

* decorator _HostBinding_ gets the property of the hosting element to which the created property should be bound

==== Setting values to custom directives
[source]
----
@Directive({
  selector: '[appBetterHighlight]'
})
export class BetterHighlightDirective implements OnInit {
  @Input() defaultColor: string = 'transparent';
  @Input() highlightColor: string = 'blue';
  @HostBinding('style.backgroundColor') backgroundColor: string;

  constructor(private elRef: ElementRef, private renderer: Renderer2) {}

  ngOnInit() {
    this.backgroundColor  = this.defaultColor;
  }

  @HostListener('mouseenter') mouseOver(eventData: Event) {
    this.backgroundColor = this.highlightColor;
  }

  @HostListener('mouseleave') mouseOver(eventData: Event) {
    this.backgroundColor = this.defaultColor;
  }
}
----

* used in HTML:
[source]
----
<p appBetterHighlight [defaultColor]="'transparent'" [highlightColor]="'green'">My colored text</p>
----
* when strings are passed as parameters, shortcut: squared brackets and single quotation marks can be ommited
[source]
----
<p appBetterHighlight [defaultColor]="'transparent'" highlightColor="green">My colored text</p>
----

=== Building own structural Directive

    ng g d unless

* = opposite of ng-if directive

[source]
----
@Directive({
  selector: '[appUnless]'
})
export class UnlessDirective {
  @Input() set appUnless(condition: boolean) {
    if(!condition) {
      this.vcRef.createEmbeddedView(this.templateRef);
    } else {
      this.vcRef.clear();
    }
  }

  constructor(private templateRef: TemplateRef<any>, private vcRef: ViewContainerRef) {}

}
----

* in HTML:
[source]
----
<div *appUnless="onlyOddNmbersOrSomeOtherBooleanProperty">
  ... stuff ...
</div>
----


== Models
* for example recipe.model.ts
* simple TypeScript file that contains the model of the data to display
* no annotation like @Model because plain TypeScript class sufficient
* best practice: if shared between multiple components, models should be put in a "shared"-folder directly below "app"

== Components & Databinding
* main question: How can data be passed between components?
* Property- and Event Binding can be applied on:
** HTML elements
** directives
** components
** self-specified, custom properties in self-written components

=== Sending data from parent component to child component
* properties per default only part of their own component and not accessible from outside
* has to be explicitly exposed to the outside-world via a decorator @Input:
----
export class MyChildComponent {
  @Input() element: {type: string, name: string, content: string};
}
----
* decorator has to be executed like a function, hence the parenthesis
* "Input" because an event gets passed into the component
* this makes the property accessible to *parent*-components of this component (!)
* parent-component can now bind to this property (in template of parent component) (element in squared brackets is the property that gets bound):
----
<div>
  <app-child-item
    *ngFor="let element of elements"
  [element]="element">
  </app-child-item>
</div>
----
* name of property viewed by the outside can be changed by using an alias. The following makes the property visible as "myUltracoolProperty":
----
export class MyWrapper {
  @Input('myUltracoolProperty') element: {type: string, name: string, content: string};
}
----

=== Sending data from child-component to parent-component
* = the other direction in regard to previous section
* used to inform parent-component about changes occurring in child-component
* in html of parent-component:
[source]
----
<my-child-component (myEvent)="onEventThrown($event)"></my-child-component>
----
* = In defining the child-component within the parent-component, the event myEvent is defined as something that can be expected to occur. If thrown, method onEventThrown with the parameter $event will be executed - see TypeScript file of parent-component:
[source]
----
export class MyParentComponent {
...
  onEventThrown(eventData: {x: string, y: string}) {
  ...
  }
...
}
----
* in child-TypeScript:
[source]
----
export class MyChildComponent {
  @Output() myEvent = new EventEmitter<{x: string, y: string}>();
  ...

  someFunctionThatGetsCalledSometime() {
    this.eventThrown.emit({'my x-value', 'my y-value'});
  }
}
----
* important: name of the event (in this case "myEvent") has to be the same in definition in child component TypeScript file as well as the parent component HTML template
* parenthesis at end of definition of eventThrown instantiate EventEmitter
* "Output" because event gets passed out of the component
* like with @Input, also alias possible:
[source]
----
export class MyChildComponent {
  @Output('mySpecialEventThrown') eventThrown = new EventEmitter<{x: string, y: string}>();
  ...

  someFunctionThatGetsCalledSometime() {
    this.eventThrown.emit({'my x-value', 'my y-value'});
  }
}
----

* EventEmitter can also pass a void value by setting "void":
[source]
----
@Output() myEvent = new EventEmitter<void>();
----

=== Sending data between neighboring components
* shown methods only allow data-passing between neighboring components via a parent-component that acts as a proxy
* especially unpractical when components are located "far away" from each other
* later another approach with Services shown

== View Encapsulation
* css-files defined per component, for example "app.component.css" for the app-component
* these CSS-files only applied to HTML generated by this component despite having global definitions in CSS-files:
[source]
----
p {
  color: blue;
}
----
* ... should be applied to all p-tags in the application, but is only applied to p-tags in component
* = different behavior than standard CSS! Only Angular-behavior!
* when inspecting code in browser, generated attributes visible:
[source]
----
<p _ngcontent-ejo-1>....</p>
----
* for each component, one of those attributes will be generated with unique names

==== Overwriting View Encapsulation
* in TypeScript-file:
[source]
----
@Component({
  ...
  encapsulation: ViewEncapsulation.None
 })
----
* ... will lead to all styles defined in this component to be applied globally
* ViewEncapsulation.Native causes the Shadow-DOM function that isn't supported by all browsers
* ViewEncapsulation.Emulated = default = recommended

== Local References
* (only!) in HTML-templates, local references can be defined and used (only) within this template (not in the TypeScript-file):
[source]
----
<input
  type="text"
  #myInput>
<button
  (click)="doStuff(myInput)">Click here</button>
----

== Accessing DOM Elements via ElementRef
* in template:
[source]
----
<input
  type="text"
  #myInput>
----
* in TypeScript:
[source]
----
export class ... {
  @ViewChild('myInput') myInput : ElementRef;
}
----
* argument of @ViewChild = name of local reference
* ElementRef = type of all @ViewChild-annotated properties
* getting underlying HTML-element:

    myInput.nativeElement

* ElementRef should only be used for accessing DOM-elements, not changing them!
* also available: @ContentChild = access to content from another component

== Component Lifecycle
* every lifecycle-step = hook that can be used to do things
* Lifecycle of every component:
1. *ngOnChanges* - whenever bound input property changes
1. *ngOnInit* - initialization
1. *ngDoCheck* - every change detection run (often!)
1. *ngAfterContentInit* - content projected into view
1. *ngAfterContentChecked* - content checked
1. *ngAfterViewInit* - view has been initialized
1. *ngAfterViewChecked* - view checked
1. *ngOnDestroy* - called before destroying an object
* ngOnChanges = only hook that recives an argument with some information:
[source]
----
 ngOnChanges(changes: SimpleChanges) {
  ...
 }
----

== Services and Dependency Injection
* Service
** can be used throughout the application to avoid duplication of code
** hold data
** used to communicate between components
* should be located near the other classes implementing the business feature of this service

=== Simple Service
* service is just a normal TypeScript-class! No _@Service_-decorator!
[source]
----
export class LoggingService {
  logSomethingToConsole(message: string) {
    console.log('This got logged: ' + message);
  }
}
----

* instances of services should be created by Angular via dependency injection, not manually. Therefore, two things necessary:
1. _provider_ with type of service
1. dependency injection in constructor

[source]
----
@Component({
  selector: 'my-cool-component',
  templateUrl: './my-cool.component.html',
  styleUrls: ['./my-cool.component.css'],
  providers: [LoggingService]
})
export class MyCoolComponent {

  constructor(private loggingService: LoggingService) {}

  ...
}
----

=== Data-holding Service
[source]
----
export class MyDataService {
  myData = [
    {
      id: 1,
      name: 'data 1'
    },
    {
      id: 2,
      name: 'data 2'
    },
    {
      id: 3,
      name: 'data 3'
    }
  ];

  addData(id: number, name: string) {
    this.myData.push({id: id, name: name});
  }
}
----
* every component using this data must hold a copy of it:
[source]
----
@Component({
  selector: 'my-cool-component',
  templateUrl: './my-cool.component.html',
  styleUrls: ['./my-cool.component.css'],
  providers: [MyDataService]
})
export class MyCoolComponent implements OnInit {

  data: {id: number, name: string}[] = [];

  constructor(private myDataService: MyDataService) {}

  ngOnInit() {
    this.data = this.myDataService.myData;
  }

  ...
}
----
* initialization of data array should not be done in constructor, but in _onInit_!

=== Hierarchical Injection
* services injected in one component can be used in all its child-components
* hence: if service provided in AppModule, this instance is available in all other components throughout the application
* if a service is *provided* in two components of the same tree, different instances of this service will be created!
* to have the same instance in two components, parent component needs entry in _providers_ *and* injection in constructor; child component *only needs injection in constructor*

=== Injecting Services into Services
* *_@Injectable()_* means, that there can be other services injected into the annotated service:
[source]
----
@Injectable()
export class MyDataService {
  myData = [
    {
      id: 1,
      name: 'data 1'
    },
    {
      id: 2,
      name: 'data 2'
    },
    {
      id: 3,
      name: 'data 3'
    }
  ];

  constructor(private logginService: LoggingService) {}

  addData(id: number, name: string) {
    this.myData.push({id: id, name: name});
    this.loggingService.logSomethingToConsole('new data added!');
  }
}
----
* _@Injectable()_ should only be added if services are injected

== JavaScript
* returning an array from a method will return a reference to this array which could be used to alter the array. To avoid this:

    return this.data.slice();
